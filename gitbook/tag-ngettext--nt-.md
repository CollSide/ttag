# nt \(tag-ngettext\) [Experimental]

> This tag is experimental and may be moved out of the core lib
> to some kind of extension.
 
### Overview

This is kind of experimental tag and can be handy when your default locale has less or more that 2 forms. \(**is not an English locale**\). 
It assumes that you have only 1 plural form in your sources, and other forms are inside the .po files.

### Usage

```js
import { nt } from 'c-3po';
const n = 5;
nt(n)`Mike has ${n} banana`
```

### Why only 1 plural form in the sources?

The decision to leave only 1 form in the sources can be confusing from the first point of view, 
but there are cases where you can benefit from it:

1. Default locale \(default language for your sources\) can have more or less then 2 plural forms. Standard **ngettext** assumes, that you have exactly 2 plural forms with no other options. So, if your default language is not English - you still need to get other plural forms from .po files, or create some workarounds for handling 1, 3, 4 plural forms with other functions.
2. If we want to make everything work without transpile step \(at a runtime on a backend\), 
we should remember that we can not use this kind of form: **ngettext\(\`${n} banana\`, \`${n} bananas\`, n\),** just because we will not receive proper **msgid **inside **ngettext** function. 
So we will end up with something like: **ngettext\(lazy\`${n} banana\`, lazy\`${n} bananas\`, n\). 
Which looks a little bit confusing and still doesn't work for other than English default locales \(because of plural forms count\).
> more about msgid is in FAQ section - [here](why-use-msgid-for-ngettext.md)
3. The third argument, that it just looks cleaner in code to have just 1 form instead of 2, 3 or more forms. 

This kind of approach leads to solution where you always have to resolve some locale \(even default\), and retrieve plural forms even for the default locale.

Anyway you can use standart [ngettext](ngettext.md) function if you want to keep all plural
forms in the code.

### 'nt' format

**Valid:**

```js
nt(n)`Mike has ${n} banana`
nt(1)`just banana`
```

**Invalid:**

```js
nt(fn())`Mike has ${fn()} banana`
nt`Mike has ${n} banana`
// e.t.c
```

### .po extraction

From the former example we will be able to extract this entry in .po file:

```
#: src/PluralDemo.js:18
msgid "Mike has ${n} banana"
msgid_plural "Mike has ${n} banana"
msgstr[0] ""
msgstr[1] ""
```

### Resolve translations

Assume we have translated entry inside .po file:

```
#: src/PluralDemo.js:18
msgid "Mike has ${n} banana"
msgid_plural "Mike has ${n} banana"
msgstr[0] "Mike has ${n} banana"
msgstr[1] "Mike has ${n} bananas"
```

The resulting compiled code will contain

```js
"use strict";

function _tag_ngettext(n, args) {
  return args[+(n != 1)];
}

_tag_ngettext(n, 
  [
    "Mike has " + n + "banana",
    "Mide has " + n + "bananas"
  ]));
```

We can see that all plural forms are injected in the code and there is a new function declared in scope -  **\_tag\_ngettext. **This function will have different implementation \(dependent on your .po file for locale\) and is autogenerated, so you don't need to pay a lot of attention to it.

### Default resolve

By default, if no translations were found c-3po will strip **nt **tag.

